# 4. 타입 확장하기·좁히기

## 4.1 타입 확장하기
타입 확장 : 기존 타입을 사용해서 새로운 타입을 정의하는 것

기본적으로 타스에서

-   타입 정의 by `interface`, `type` 키워드 사용
-   타입 확장 by `extends`, 교차 타입, 유니온 타입

### 1. 타입 확장의 장점

-   **불필요한 코드 중복을 줄일 수 있다**
-   **명시적인 코드를 작성할 수 있음**
-   확장성

### 2. 유니온 타입

타스의 타입을 속성의 집합이 아니라 값의 집합이라고 생각해야 유니온 타입이 합집합이라는 개념을 이해할 수 있다


### 4. extends와 교차 타입
`A extends B`

-   A는 B의 모든 타입/속성을 포함한다
-   A는 B의 상위 집합이 되고, B는 A의 부분집합이 된다.

유니온 타입과 교차 타입을 사용한 새로운 타입은 오직 type 키워드로 선언할 수 있다

## 4.2 타입 좁히기 - 타입 가드

타스에서 타입 좁히기 : 변수 또는 표현식의 타입 범위를 좀 더 좁혀나가는 과정

-   **장점**
    -   **좀 더 정확하고 명시적인 타입 추론 가능**
    -   **타입 안정성을 높일 수 있음**
 
### 1. 타입 가드에 따라 분기 처리하기

타스에서 분기 처리 : 조건문과 타입 가드를 활용해서 타입을 좁혀 다양한 상황에 따라 다른 동작을 하는 것

타입 가드 : 런타임에 조건문을 사용해서 타입을 검사하고 타입 범위를 좁히는 기능


### 2. 원시 타입을 추론할 때: typeof 연산자 활용하기

주로 원시 타입을 좁히는 용도로 사용하는거 추천

### 3. 인스턴스화된 객체 타입을 판별할 때: instanceof 연산자 활용하기

typeof 연산자와는 다르게 객체 타입을 판별할때 사용할 수 있다.

사용

`A instance of B`

A : 타입을 검사할 변수

B : 특정 객체의 생성자

### 4. 개체의 속성이 있는지 없는지에 따른 구분: in 연산자 활용하기

객체에 속성이 있는지 확인

### 5. is 연산자로 사용자 정의 타입 가드 만들어 활용하기

반환 타입을 타입 명제로 하는 타입 가드 함수를 직접 만들 수 있다

사용

A is B

A : 매개변수 이름

B : 타입

## 4.3 타입 좁히기 - 식별할 수 있는 유니온(Discriminated Union)


### 2. 식별할 수 있는 유니온

개발 과정에서 의미를 알 수 없는 수많은 에러 객체가 생겨날 위험성이 커짐 -> 에러 타입을 구분할 방법이 필요 by 식별할 수 있는 유니온

식별할 수 있는 유니온 : 타입 간의 구조 호환을 막기 위해 타입마다 구분할 수 있는 판별자를 달아줘 포함 관계를 제거하는 것

사용시 정확하지 않은 에러 객체에 대해 타입 에러가 발생한다

### 3. 식별할 수 있는 유니온의 판별자 선정

유닛 타입으로 선언돼야 타입이 좁혀진다.

유닛타입 : 쪼개지지 않고 오직 하나의 정확한 값을 가지는 타입

ex) null, undefined, 리터럴 타입, true, 1

!유닛타입 ex) void, string, number

## 4.4 Exhaustiveness Checking으로 정확한 타입 분기 유지하기

*exhaustiveness checking…? 정말 생소하다.*

exhaustiveness checking : 모든 케이스에 대해 철저하게 타입을 검사하는 것

장점 : 예상치 못한 런타임 에러를 방지하거나 요구사항이 변경됐을 때 생길 수 있는 위험성을 줄일 수 있다.

