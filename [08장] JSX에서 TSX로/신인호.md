# 8. JSX에서 TSX로

## 8.1 리액트 컴포넌트의 타입

### 1. 클래스 컴포넌트 타입

```tsx
interface Component<P = {}, S = {}, SS = any> extens ComponentLifecycle<P, S, SS> {}
// 	props: P, state: S;

class Component<P, S> { /* ... */  }

class PureComponent<P = {}, S = {}, SS = any> extends Component<P, S, SS> {}
```

예시로 Welcome 클래스 컴포넌트를 만들어보자.

```tsx
interface WelcomeProps {
  name: string;
}

class Welcome extends React.Component<WelcomeProps> {
  render() {
    return <h1>Hello, {this.props.name}</h1>;
  }
}
```

상태를 가지는 클래스 컴포넌트를 만들어보자. 제네릭의 `두번째 타입은 상태의 타입`을 지정한다.

```tsx
// 상태의 타입을 지정
interface TimerState {
  time: Date;
}

// 상태를 가지는 클래스 컴포넌트
class Timer extends React.Component<{}, TimerState> {
  // 상태의 초기값을 설정
  state = { time: new Date() };

  render() {
    return <div>{this.state.time.toISOString()}</div>;
  }
}
```

### 2. 함수 컴포넌트 타입

```tsx
// 함수 선언식
function Welcome(props: WelcomeProps) {}

// 함수 표현식 - React.FC 사용
const Welcome: React.FC<WelcomeProps> = (props) => {};

// 함수 표현식 - React.VFC 사용
const Welcome: React.VFC<WelcomeProps> = (props) => {};

// 함수 표현식 - JSX.Element를 반환 타입으로 지정
const Welcome = (props: WelcomeProps): JSX.Element => {};
```

리액트 컴포넌트의 타입을 지정할 때는 `React.FC` 또는 `React.VFC`를 사용한다. `FC`는 `FunctionComponent`의 줄임말로 함수형 컴포넌트를 의미한다. `@types/react 16.9.4버전`에서 `React.VFC`가 추가되었는데, `React.FC`와 동일한 역할을 한다. `React.FC`는 `children`이라는 props를 기본적으로 포함하고 있지만, `React.VFC`는 `children`을 포함하고 있지 않다.

하지만 리액트 v18로 넘어오면서 React.VFC가 삭제되고 React.FC에 children이 사라졌다. 그래서 React.FC를 사용하면 된다.

### 3. Children props 타입 지정

```tsx
type PropsWithChildren<P> = P & { children?: ReactNode | undefined };
```

가장 보편적인 `children` 타입은 `ReactNode | undefined`이다. 만약 특정 타입을 지정하고 싶다면 `children` 에 추가로 타입을 지정하면 된다.

```tsx
// example1
type WelcomeProps = {
  children: "천생연분" | "더 귀한 분" | "귀한 분" | "고마운 분";
};

// example2
type WelcomeProps = {
  children: string;
};

// example3
type WelcomeProps = {
  children: ReactElement;
};
```

### 4. render 메서드와 함수 컴포넌트의 반환 타입 - React.ReactElement vs JSX.Element vs React.ReactNode

- `React.ReactElement`는 함수 컴포넌트의 반환 타입이다. 리액트는 실제 DOM이 아닌 가상 DOM을 기반으로 렌더링하는데 가상 DOM의 엘리먼트는 `ReactElement`로 저장된다. 즉, `ReactElement`는 리액트 컴포넌트를 객체 형태로 저장하기 위한 포맷이다.

```tsx
interface ReactElement<
  P = any,
  T extends string | JSXElementConstructor<any> =
    | string
    | JSXElementConstructor<any>
> {
  type: T;
  props: P;
  key: Key | null;
}
```

- `JSX.Element`는 JSX로 반환하는 함수의 반환 타입이다. 리액트 ReactElement를 확장하고 있는 타입이며, 글로벌 네임스페이스에 정의되어 있어 외부 라이브러리에서 컴포넌트 타입 재정의와 변경에 용이하다.

```tsx
declare global {
  namespace JSX {
    interface Element extends React.ReactElement<any, any> {}
  }
}
```

> #### 글로벌 네임스페이스(Global Namespace)
>
> 프로그래밍에서 식별자(변수, 함수, 타입 등)가 정의되는 전역 범위를 의미한다. 즉, 해당 스코프에 선언된 식별자는 **모든 파일**에서 접근할 수 있다.

`React.ReactNode`는 리액트 엘리먼트 외에도 여러타입을 포함하고 있다.

```tsx
type ReactNode =
  | ReactChild
  | ReactFragment
  | ReactPortal
  | boolean
  | null
  | undefined;

type ReactText = string | number;
type ReactChild = ReactElement | ReactText;
type ReactFragment = {} | Iterable<ReactNode>;
```

- 포함 관계는 다음과 같다.
  `(작은 범위) JSX.Element -> ReactElement -> ReactNode (큰 범위)`

### 5. ReactElement, ReactNode, JSX.Element 활용하기

#### ReactElement

JSX는 리액트 엘리먼트를 생성하는 문법이며, 트랜스파일러에서는 `JSX`를 `React.createElement`로 변환한다. `React.createElement`는 `ReactElement`를 반환한다.

즉, `ReactElement` 타입은 JSX의 `createElement` 메서드 호출로 생성된 리액트 엘리먼트를 나타내는 타입이다.

#### ReactNode

`ReactChild` 타입은 `ReactElement | string | number`로 정의되어 `ReactElement` 보다 넓은 범위이다. `ReactNode` 는 `ReactChild` 타입 외에도 훨씬 넓은 범주의 타입을 포함한다.

즉, `ReactNode` 는 리액트의 `render` 함수가 반환할 수 있는 모든 타입을 담고 있다.

#### JSX.Element

`JSX.Element` 는 `ReactElement` 의 확장된 타입이다. props와 타입 필드를 any로 가지는 타입이다.

### 6. 사용 예시

어떤 상황에서 3가지 타입을 사용해야 하는지 알아보자.

#### ReactNode

어떤 타입이든 children prop으로 지정하고 싶다면 `ReactNode`를 사용하면 된다.

```tsx
type WelcomeProps<P = unknown> = P & {
  children?: ReactNode | undefined;
};
```

#### JSX.Element

리액트 엘리먼트를 prop으로 받아 render props 패턴으로 컴포넌트를 구현할 때 활용한다.

```tsx
interface Props {
  icon: JSX.Element; // any 타입으로 추론됨.
}

const Item = ({ icon }: Props) => {
  const iconSize = icon.props.size;

  return <li>{icon}</li>;
};

// 사용 예시
const App = () => {
  return <Item icon={<Icon size={14} />} />;
};
```

#### ReactElement

JSX.Element 대신에 ReactElement를 사용하면 원하는 타입을 지정할 수 있다. 이전에 JSX.Element를 사용했던 예시에서 props의 타입이 any로 추론되는 문제를 해결할 수 있다.

```tsx
interface IconProps {
  size: number;
}

interface Props {
	// props의 타입을 IconProps로 지정
  icon: React.ReactElement<IconProps>;
}

// const Item: React.FC<Props> = ({ icon }) => {
const Item = ({ icon }: Props) => {
  // icon prop으로 받은 컴포넌트의 props에 접근하면, props의 목록이 추론된다.
  const iconSize = icon.props.size;

  return <li>{icon}</li>;
};

// 사용 예시
<Item icon={<Icon size={14} />} />;
```

### 7. 리액트에서 기본 HTML 요소 타입 활용하기

#### DetailedHTMLProps와 ComponentWithoutRef

- DetailedHTMLProps 을 사용하면 HTML 태그 속성과 호환된다.

```tsx
type NativeButtonProps = React.DetailedHTMLProps<
  React.ButtonHTMLAttributes<HTMLButtonElement>,
  HTMLButtonElement
>;

type ButtonProps = {
  onClick?: NativeButtonProps["onClick"];
};
```

- ComponentWithoutRef 도 실제 HTML button 태그의 onClick 이벤트 핸들러 타입에 할당할 수 있다.

```tsx
type NativeButtonType = React.ComponentPropsWithoutRef<"button">;
type ButtonProps = {
  onClick?: NativeButtonType["onClick"];
};
```

#### 언제 ComponentWithoutRef 를 사용하면 좋을까

TypeScript에서 React 컴포넌트를 정의할 때, 해당 컴포넌트가 ref를 지원하지 않음을 명시적으로 나타내고 싶을 때 사용한다. 이는 주로 ref를 사용하지 않는 컴포넌트에서 예기치 않은 에러가 발생하지 않도록 하는데 도움이 된다.

> #### ref
>
> 생성된 DOM 노드나 리액트 엘리먼트에 접근하기 위한 방법이다. useRef 훅을 사용하거나 React.createRef 함수를 사용하여 ref를 생성할 수 있다. ref를 통해 DOM 노드를 조작할 수 있다.

#### forwardRef를 사용해 ref를 전달받을 수 있도록 구현

함수 컴포넌트에서는 생성된 인스턴스가 없기 때문에 ref에 기대한 값이 할당되지 않는다. 이때 `forwardRef`를 사용하면 ref를 전달받을 수 있다. 2개의 제네릭 인자를 받는데, 첫 번째는 ref의 타입이고 두 번째는 컴포넌트의 props 타입이다.

```tsx
// HTML button의 ref 속성을 제거.
type NativeButtonType = React.ComponentPropsWithoutRef<"button">;

// forwardRef의 제네릭 인자로 ref 타입을 HTMLButtonElement로 지정, props 타입은 NativeButtonType으로 지정.
const Button = forwardRef<HTMLButtonElement, NativeButtonType>((props, ref) => {
  return (
    <button ref={ref} {...props}>
      버튼
    </button>
  );
});

const WrappedButton = () => {
  const buttonRef = useRef();

  return <Button ref={buttonRef} />;
};
```

**_이해 안가서 적어두는 요약_**

- `forwardRef`: 부모 컴포넌트가 자식 컴포넌트의 DOM 요소나 클래스 인스턴스에 접근해야 할 때 사용됩니다. 예를 들어, 부모 컴포넌트가 자식 컴포넌트의 버튼에 focus를 설정해야 하는 경우입니다.
- `ComponentWithoutRef`: 컴포넌트가 ref를 지원하지 않음을 명시적으로 나타내고 싶을 때 사용됩니다. 이는 주로 단순한 프레젠테이션 컴포넌트나 ref를 사용하지 않는 컴포넌트를 정의할 때 유용합니다.
