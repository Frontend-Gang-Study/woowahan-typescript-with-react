# 3장 고급 타입



## 3.1 타입스크립트만의 독자적 타입 시스템
타스의 타입 시스템이 내포하고 있는 개념은 모두 자스에서 기인했다.

### 1. any 타입
- 열린 타입

타스의 컴파일러 설정을 커스텀할 수 있는 tsconfig.json 파일에서 noImplicitAny 옵션을 활성화하면 타입이 명시되지 않은 변수의 암묵적인 any 타입에 대한 경고를 발생시킬 수 있다.
*까비엔 noImplicitAny 활성화 돼있지 않네*

any는 임시로 타입을 지정할 때 주로 사용되므로 타입에 대한 세부 스펙이 나오는 시점에 다른 타입으로 대체해야 한다.

### 2. unknown 타입

우형 이야기에서 어떤 팀은 any보다 unknown을 좀 더 많이 사용하는 것 같다 함. 
*난 any 밖에 사용한 적이 없어서 신기하다.* 

"any는 무엇이든 괜찮다, unknown은 뭔지 모르지만 하나씩 테스트하면서 뭔지 알아내보자 라는 의미로 생각한다"
*any를 나보다 긍정적으로 생각하시는 것 같아서, 나도 무조건 any를 배척하고픈 마음을 다시 돌아봐야겠다는 생각이 듦*

### 3. void 타입
함수에서 명시적인 반환문을 작성하지 않으면,

자스에선 기본적으로 undefined가 반환된다.

↕️

타스에선 반환값 타입으로 void가 지정된다.

주로 함수 반환 타입으로 사용되지만 함수에 국한되지 않는다

### 4. never 타입
void와 마찬가지로 함수와 관련해서 많이 사용되는 타입이다. 
*그렇구나 난 never 사용 한번도 안해봤어.*


### 5. Array 타입
Array 키워드는 배열 타입을 가리킨다

타스뿐만 아니라 다른 정적 언어에서도 배열의 원소로 하나의 타입만 사용하도록 명시한다.

스프레드 연산자를 사용해서 튜플과 배열의 성질을 혼합해 사용할 수 있다

### 6. Enum 타입
자스와 다른 점
- 명명한 각 멤버의 값을 스스로 추론한다
- 각 멤버에 명시적으로 값을 할당할 수 있다.

장점
- 명확한 의미 전달
- 높은 응집력
- 코드의 가독성을 높여줌

열거형은 관련이 높은 멤버를 모아 문자열 상수처럼 사용하고자 할때 유용하다.

## 3.2 타입 조합

### 1. 교차 타입(Intersection)
- &
- A & B : 타입 A와 타입 B를 모두 만족하는 타입

### 2. 유니온 타입(Union)
- |
- A | B : 타입 A 또는 타입 B 중 하나가 될 수 있는 타입

### 교차 타입과 유니온의 공통점
- 생성된 타입에 타입 별칭을 붙일 수 있다
- 2개 이상의 타입을 이어 붙일 수 있다
- 여러 줄에 걸쳐 표기할 수 있다

### 3. 인덱스 시그니처(Index Signatures)
인터페이스 내부에 `[Key : K]: T` 형태로 타입 명시

*까비 api 응답에 에러 객체 받을때 사용하면 좋을듯.*

### 4. 인덱스드 엑세스 타입(Indexed Access Types)
다른 타입의 특정 속성이 갖는 타입 조회할 때 사용

### 5. 맵드 타입(Mapped Types)
보통 map : 유사한 형태를 가진 여러 항목의 목록 A를 변환된 항목의 목록 B로 바꾸는 것

맵드 타입은 다른 타입을 기반으로 한 타입을 선언할 때 사용

### 6. 템플릿 리터럴 타입(Template Literal Types)

```
type Stage = | "init" | "select-image" | "edit-image" | "decorate-card" | "capture-image";
type StageName = `${Stage}-stage`; 
// ‘init-stage’ | ‘select-image-stage’ | ‘edit-image-stage’ | ‘decorate-card-stage’ | ‘capture-image-stage’
```

*엄청 유용한데..? 까비 store에 사용가능할듯*

### 7. 제네릭(Generic)
보통 타입 변수명으로 T(type), E(element), K(key), V(value) 등 한 글자를 많이 사용한다.

*여태껏 T를 많이 봤어*

제네릭 함수를 호출할 때 반드시 꺽쇠괄호 안에 타입을 명시해야 하는 것은 아니다. <- 생략시 컴파일러가 인수를 보고 타입을 추론한다.

## 3.3 제네릭 사용법

### 1. 함수의 제네릭
특정 함수의 매개변수나 반환 값에 다양한 타입을 넣고 싶을 때 사용할 수 있다

*예시보니까 숨이 턱∙∙∙.. 쉬운 예시 찾기*

```
function getFirstElement<T>(arr: T[]): T | undefined { return arr[0]; }
```

### 3. 제네릭 클래스
외부에서 입력된 타입을 메서드의 매개변수 또는 반환 타입 등 클래스 내부에 적용할 수 있는 클래스

### 4. 제한된 제네릭 (extends)
타입 매개변수에 대한 제약 조건을 설정하는 기능


### 5. 확장된 제네릭

    <Key extends string>

타입을 이런식으로 제약하면 제네릭의 유연성을 잃어버린다
-> 타입 매개변수에 유니온 타입을 상속

    <Key extends string | number>

### 6. 제네릭 예시

실제 현업에서 제네릭이 제일 많이 활용되는 때 : API 응답 값의 타입을 지정할 때

제네릭 타입 사용의 장점
- 가독성 높임
- 코드 효율적으로 재사용
- 타입 추론 가능
- 타입 검사 가능

제네릭 타입 사용의 역효과
- 제네릭 타입이 다른 곳에선 사용되지 않고, 한 곳에서만 사용될때
-   any를 사용하면 제네릭의 장점을 누릴 수 없다. 
-   제네릭을 남용하면 가독성이 안좋아진다.
     -> 어쩔 수 없는 상황 제외하고 복잡한 제네릭은 의미 단위로 분할해서 사용하는게 좋다
