# 12. 타입스크립트 프로젝트 관리

## 12.1 앰비언트 타입 활용하기

### 1. 앰비언트 타입 선언

타입스크립트의 타입 선언은 `.ts`, `.tsx` 확장자를 가진 파일에서 할 수 있지만 `.d.ts` 확장자를 가진 파일에서도 선언할수 있다.

#### 앰비언트 타입 선언

`.d.ts` 확장자를 가진 파일에서는 타입 선언만 할 수 있고 값을 표현할 수는 없다. 값을 포함하는 일반적인 선언과 구별하기 위해서 `.d.ts` 확장자를 가진 파일에서 선언하는 타입을 앰비언트 타입 선언이라고 부른다.

> 앰비언트(ambient)는 사전적으로 '주변의'란 의미이다.

`declare`라는 키워드를 사용하여 어딘가에 자바스크립트 값이 존재한다는 사실을 알려줄 수 있다.

> `declare`는 타입스크립트 컴파일러에 어떤 것의 존재 여부를 명시해주는 역할을 한다. 단순히 존재 여부만 알려주기 때문에 컴파일 대상이 아니다.

#### 대표적인 앰비언트 타입 선언 활용 사례

타입스크립트는 기본적으로 `.ts`, `.js` 파일만 이해하며 그 외의 다른 파일 형식은 인식 못한다. 알지 못하는 파일 형식을 모듈로 가져오려 하면 에러가 난다. 이럴 때 `declare` 키워드를 사용하여 타입을 선언하면 에러가 나지 않는다.

```ts
declare module "*.png" {
  const src: string;
  export default src;
}
```

위 코드는 png 파일을 모듈로 가져올 때 타입을 선언한 것이다. 이렇게 선언하면 타입스크립트 컴파일러가 png 파일을 모듈로 인식하게 된다.

#### 자바스크립트로 작성된 라이브러리

자바스크립트로 작성된 npm 라이브러리를 사용할 때 타입 선언이 없어 임포트한 모듈을 모두 `any`로 추론될 것이다. 이때 앰비언트 타입 선언을 사용하여 타입 정보를 추가할 수 있다.

앰비언트 타입 선언은 타입스크립트에게 '자바스크립트 코드 안에는 이러한 정보들이 있어'라고 알려주는 도구라고 이해하면 된다.

#### 타입스크립트로 작성된 라이브러리

라이브러리를 사용 중인 타입스크립트 파일을 컴파일 할 때 라이브러리 코드도 함께 컴파일하게 할 수도 있다. 그러나 자바스크립트 파일과 `.d.ts` 파일로 배포하면 라이브러리 코드를 따로 컴파일하지 않아도 되기 때문에 컴파일 시간이 크게 줄어든다.

또한 `.d.ts` 파일이 있기 때문에 사용자가 `.d.ts` 파일에 정의된 타입 정보를 활용하여 라이브러리를 사용할 수 있다.

`tsconfig.json` 파일의 `declaration` 옵션을 `true`로 설정하면 타입스크립트 컴파일러가 자동으로 `.d.ts` 파일을 생성한다.

```json
{
  "compilerOptions": {
    "declaration": true
  }
}
```

#### 자바스크립트 어딘가에 전역 변수가 정의되어 있음을 타입스크립트에 알릴 때

타입스크립트로 직접 구현하지 않았지만 실제 자바스크립트 어딘가에 전역 변수가 정의되어 있는 상황을 타입스크립트에 알릴 때 앰비언트 타입 선언을 사용한다.

예로 웹뷰를 개발할 때 `Window` 객체에 네이티브 앱과의 통신을 위한 인터페이스를 추가하는 경우가 많다. 네이티브 앱에서 `Window` 전역 객체에 `deviceId`나 `appVersion` 같은 값을 할당해주는 시나리오가 있다고 가정하자. 이때 타입스크립트는 `Window` 객체에 `deviceId`나 `appVersion`이라는 프로퍼티가 없다고 에러를 표시할 것이다. 이럴 때 앰비언트 타입 선언을 사용하여 `Window` 객체에 `deviceId`나 `appVersion`이라는 프로퍼티가 있다고 타입스크립트에 알려줄 수 있다.

```ts
declare global {
  interface Window {
    deviceId: string | undefined;
    appVersion: string;
  }
}
```

### 2. 앰비언트 타입 선언 시 주의점

#### 타입스크립트로 만드는 라이브러리에는 불필요

`tsconfig.json`의 `declaration`을 `true`로 설정하면 타입스크립트 컴파일러가 자동으로 `.d.ts` 파일을 생성해주기 때문에 타입스크립트로 만드는 라이브러리에는 앰비언트 타입 선언을 사용할 필요가 없다.

#### 전역으로 타입을 정의하여 사용할 때 주의해야 할 점

서로 다른 라이브러리에 동일한 이름의 앰비언트 타입 선언을 한다면 충돌이 발생하여 어떤 타입 선언이 적용될지 알 수 없다.

### 3. 앰비언트 타입 선언을 잘못 사용했을 때의 문제점

`.ts` 파일 내의 앰비언트 변수 선언은 개발자에게 혼란을 야기할 수 있다. 앰비언트 타입은 명시적인 임포트나 익스포트 없이 코드 전역에서 사용할 수 있기 때문에 의존성 관계가 보이지 않아 변경에 의한 영향 범위를 파악하기 어렵다. 소스코드 규모가 크다면 추후 변경이 어려워질 수 있다.

`.ts`, `.tsx` 파일 내에서 `declare` 키워드를 사용해 앰비언트 타입 선언이 가능하다.

```ts
// src/index.tsx
import React from "react";
import ReactDOM from "react-dom";
import App from "./App";

declare global {
  interface Window {
    Example: string;
  }
}

const SomeComponent = () => {
  return <div>앰비언트 타입 선언은 .tsx 파일에서도 가능</div>;
};

// src/test.tsx
window.Example; // 앰비언트 타입 선언으로 인해 타입스크립트 에러가 발생하지 않는다.
```

이렇듯 어느 곳에서나 앰비언트 변수 선언이 가능하기 때문에 .d.ts 파일 내에서 앰비언트 타입 선언을 하는 것이 일종의 개발자 간의 약속이다. 타입 선언 위치가 명확해야 가독성이 높아지고 유지보수도 쉬워진다.

### 4. 앰비언트 타입 활용하기

컴파일러에 타입 정보를 알려주는 `declare` 키워드를 효과적으로 활용해보자.

#### 타입을 정의하여 임포트 없이 전역으로 공유

`.d.ts` 파일에 앰비언트 타입 선언은 전역 변수와 같은 역할을 한다. 모든 코드 내에서 임포트하지 않고 사용할 수 있다. 예를 들어 유틸리티 타입을 선언하면 마치 내장 타입 유틸리티 함수를 사용하는 것처럼 사용할 수 있다.

```typescript
// src.index.d.ts
type Optionl<T extends object, K extends keyof T = keyof T> = Omit<T, K> &
  Partial<Pick<T, K>>;

// src/components.ts
type Props = { name: string; age: number; visible: boolean };
type OptionalProps = Optional<Props>; // Expect: { name?: string; age?: number; visible?: boolean; }
```

**_보충 예시_**

```ts
type Example = {
  a: string;
  b: number;
  c: boolean;
};

type OptionalExample = Optional<Example, "a" | "b">;

// OptionalExample 타입은 다음과 같다:
// {
//   c: boolean;
//   a?: string;
//   b?: number;
// }
```

#### declare type 활용하기

보편적으로 사용하는 커스텀 유틸리티 타입을 `declare type`으로 선언해 전역에서 사용할 수 있다.

```typescript
// Nullable
declare type Nullable<T> = T | null;

const name: Nullable<string> = "woowa";
```

#### declare module 활용하기

CSS-in-JS 라이브러리에서 theme 인터페이스 타입을 확장하여 theme 타입이 자동으로 완성되도록 하는 기능이 추가되었다.

```tsx
const fontSizes = {
  xl: "24px",
  // ...
};

const colors = {
  gray_100: "#222222",
  gray_200: "#444444",
  // ...
};

const theme = {
  fontSizes,
  colors,
};

declare module "styled-components" {
  type Theme = typeof theme;

  export interface DefaultTheme extends Theme {}
}
```

#### declare namespace 활용하기

`.env` 파일을 사용할 때, `declare namespace을` 활용해 `process.env`로 설정값을 손쉽게 불러오고 환경변수의 자동 완성 기능을 쓸 수 있다.

```ts
declare namespace NodeJS {
  interface ProcessEnv {
    readonly API_URL: string;
    readonly API_INTERNAL_URL: string;
    // ...
  }
}
```

#### declare global 활용하기

전역 변수를 선언할 때 사용한다. 예를 들어 Window 객체에 전역 변수를 추가할 때 사용한다.

```ts
declare global {
  interface Window {
    newProperty: string;
  }
}
```

iOS 웹뷰에서 자바스크립트로 네이티브 함수를 호출하기 위한 함수를 정의해보자.

```ts
declare global {
  interface Window {
    webkit?: {
      messageHandlers?: Record<
        string,
        { postMessage?: (parameter: string) => void }
      >;
    };
  }
}
```

### 5. declare와 번들러의 시너지

`declare global`로 전역 변수를 선언하는 과정과 번들러를 통해 데이터를 주입하는 절차를 함께 활용하면 좋다. 아래 코드에서 color를 번들러를 통해 주입하고, `_color` 데이터를 사용할 수 있다. 이 과정을 하지 않는다면, `_color` 객체의 실제 데이터가 존재하지 않는다. 타입스크립트 에러가 발생하지는 않지만 기대하는 동작과 다를 수 있다.

```ts
// data.ts
const color = {
  red: "#ff0000",
  green: "#00ff00",
  blue: "#0000ff",
} as const;

// type.ts
import { color } from "./data";
type ColorSet = typeof color;

declare global {
  const _color: ColorSet;
}

// index.ts
console.log(_color["red"]); // #ff0000

// rollup.config.js
import typescript from "@rollup/plugin-typescript";
import inject from "@rollup/plugin-inject";

export default [
  {
    input: "index.ts",
    output: [
      {
        dir: "lib",
        format: "esm",
      },
    ],
    plugins: [typescript(), inject({ _color: ["./data", "color"] })],
  },
];
```

```ts
const red = _color["red"]; // 정상 동장
```

## 12.2 스크립트와 설정 파일 활용하기

스크립트와 `tsconfig` 등을 활용하여 타입스크립트 프로젝트를 관리하는 방법을 알아보자.

### 1. 스크립트 활용하기

#### 실시간으로 타입을 검사하자

아래 스크립트를 사용하면 실시간으로 에러를 확인할 수 있다.

```bash
yarn tsc --noEmit --incremental -w
```

**설명**

- `tsc` 명령어는 타입스크립트 컴파일러를 실행하는 명령어이다.
- `--noEmit` 옵션은 컴파일 결과물을 생성하지 않는 옵션이다.
- `--incremental` 옵션은 타입스크립트 컴파일러가 이전 컴파일 결과물을 재사용하여 컴파일 속도를 높이는 옵션이다.
- `-w` 옵션은 파일을 감시하고 변경사항이 있을 때마다 컴파일을 실행하는 옵션이다.

#### 타입 커버리지 확인하기

`any`를 남발하면 타입스크립트를 사용하는 의미가 없어진다. 타입스크립트로 작성된 코드 중 `any`를 사용한 코드의 비율을 확인하고 줄여나가는 것이 중요하다.

```bash
npx type-coverage --detail
```

이 스크립트를 사용하면 현재 프로젝트의 타입 커버리지와 `any`를 사용하고 있는 변수의 위치가 나타난다. 또한 변수에 타입이 얼마나 지정되어 있는지 퍼센트로 확인할 수 있다.

### 2. 설정 파일 활용하기

#### 타입스크립트 컴파일 속도 높이기

`tsconfig.json` 파일에 `incremental` 옵션을 추가하면 증분 컴파일이 활성화되어 매번 모든 대상을 컴파일하는 것이 아니라 변경된 부분만 컴파일하게 된다. 타입스크립트 컴파일 속도를 높일 수 있다.

- `tsconfig.json` 파일에 설정 추가

  ```json
  {
    "compilerOptions": {
      "incremental": true
      // ...
    }
  }
  ```

- 스크립트 활용
  ```bash
  yarn tsc --noEmit --incremental --diagnostic
  ```

### 3. 에디터 활용하기

가끔 IDE에서 타입 자동 완성 기능이 동작하지 않는 경우, 타입스크립트 서버를 재실행하면 된다. VSCode에서 `Restart TS server` 명령어를 실행하면 된다. (Cmd + Shift + P)

## 12.3 타입스크립트 마이그레이션

자바스크립트 프로젝트를 타입스크립트로 마이그레이션하는 사례를 알아보자.

### 1. 타입스크립트 마이그레이션의 필요성

빠르게 변화하는 비즈니스 환경에서는 기존 코드의 구조적인 한계가 드러날 수 있다. 이 상황에서 마이그레이션은 현재 비즈니스 로직에 맞지 않는 인터페이스만 추가하는 작업에 불과할 수 있다.

프로젝트의 규모와 특성 및 내외부 여건을 종합적으로 고려하여, 기존 프로젝트를 신규 프로젝트로 바꾸는 게 나을지 단순히 마이그레이션하는 게 나을지를 신중하게 따져봐야 한다.

### 2. 점진적인 마이그레이션

타입스크립트는 작은 부분부터 점진적으로 마이그레이션을 시작할 수 있기 때문에 진입 장벽이 낮아지고 프로젝트의 전반적인 동작을 안정적으로 유지할 수 있게 된다.

하지만 단순히 `allowJS`를 `true`, `noImplicitAny`를 `false`로 설정한 채 무기한으로 마이그레이션을 미루는 것은 지양해야 한다.

점진적으로 타입스크립트 마이그레이션을 진행하기로 했다면, 프로젝트 참여자와 함께 **우선순위를 대략적이라도 설정**해두는 게 좋다.

### 3. 마이그레이션 진행하기

다음 단계를 거치게 된다.

1. 타입스크립트 개발 환경 설정, 빌드 파이프라인에 타입스크립트 컴파일러 통합. `tsconfig.json` 파일에 `allowJS: true`, `noImplicitAny: false` 설정.

> #### allowJS
>
> 기존 자바스크립트 함수를 타입스크립트에서 임포트하거나 반대로 타입스크립트 함수를 자바스크립트에서 임포트할 수 있게 해준다.
>
> #### noImplicitAny
>
> 암시적 any 타입이 있을 때 오류가 발생하게 하는 옵션이다.

2. 작성된 자바스크립트 파일을 타입스크립트 파일로 변환. 타입과 인터페이스를 정의하며 함수 시그니처 추가.
3. 기존 자바스크립트 파일을 모두 타입스크립트로 변환 완료. `tsconfig.json` 파일에 `allowJS: false`, `noImplicitAny: true` 설정해 타입이 명시되지 않은 부분 없는지 점검.

## 12.4 모노레포

여러 프로젝트를 관리하는 상황에서 공통적인 요소를 통합하는 과정을 살펴본다.

### 1. 분산된 구조의 문제점

독립적인 프로젝트가 여러개 있다고 가정해보자. 각 레포지토리에 Jest, 바벨, ESLint, 타입스크립트 등 설정 파일을 별도로 구성하고 빌드 파이프라인, 공통적인 컴포넌트 등 소스코드를 독립적으로 관리하고 있다.

다른 프로젝트에 필요한 기능을 복사 붙여놓기로 빠르게 구현할 수 있지만, 이런 방식은 유지보수성이 떨어지고 중복된 코드가 많아진다.

개발자가 변경이 필요한 지점을 모두 인지하고 있어야 하기 때문에 개발자 경험(DX)이 저하될 수 있다. 장기적으로도 프로젝트 관리가 어려워지면서 업무 효율이 갈수록 악화되는 현상이 발생하게 된다.

**반복되는 코드를 함수화하여 통합하듯이 한 곳에서 프로젝트를 관리할 수 있도록 통합해야 한다.**

### 2. 통합할 수 있는 요소 찾기

각 프로젝트의 utils 디렉토리는 공통적인 요소를 포함하고 있다. 이를 통합하여 관리하면 중복 코드를 줄일 수 있다.

### 3. 공통 모듈화로 관리하기

npm과 같은 패키지 관리자를 활용하여 공통 모듈을 생성하고 관리한다면 각 프로젝트에서 간편하게 모듈과 의존성을 맺고 사용할 수 있게 된다. 새로운 프로젝트를 시작하더라도 모듈을 통해 코드를 재사용할 수 있으며, 특정 기능의 변경이 필요할 때는 해당 모듈의 소스코드만 수정하면 되기 때문에 유지보수도 쉬워진다.

아쉬운 점: 모듈을 사용하는 프로젝트가 많아질수록 모듈의 버전 관리가 어려워진다. 모듈을 업데이트할 때마다 모든 프로젝트에서 해당 모듈을 사용하는 부분을 수정해야 한다.

새로운 공통 모듈이 필요하다면 개발자는 새로운 레포지토리를 생성하고 개발 환경을 설정하며 패키지 관리자를 사용하여 모듈을 게시해야 한다. 새로운 프로젝트를 시작할 때도 빌드를 위한 CI/CD 파이프라인, Lint, 테스트 등도 별도로 설정해야 한다.

### 4. 모노레포의 탄생

모노레포란 버전 관리 시스템에서 여러 프로젝트를 하나의 레포지토리로 통합하여 관리하는 소프트웨어 개발 전략이다.

이전에는 다양한 기능을 가진 프로젝트를 하나의 레포지토리로 관리하는 모놀리식 기법을 주로 사용했다. 하지만 모놀리식 구조는 코드 간의 직접적인 의존이 발생해 일부 로직만 변경될 때도 전체 프로젝트에 영향을 줄 수 있다. 설계적인 측면과 빌드 및 배포 등에서 효율적이지 못했다.

효율적인 구조에 대한 수요로 거대한 프로젝트를 작은 프로젝트의 집합으로 나누어 관리하는 폴리레포 방식과 하나의 레포지토리로 모든 것을 관리하는 모노레포 방식이 등장했다.

모노레포를 사용하면 개발 환경 설정도 통합할 수 있어서 더 효율적인 관리가 가능해진다. 우아한형제들도 10개 이상의 내부 프로젝트가 모노레포로 진행되고 있다. 그만큼 유용하게 활용할 수 있는 구조이다.

#### 모노레포로 관리했을 때의 장점

여러 프로젝트를 하나의 레포지토리로 통합하여 관리하며, 프로젝트마다 개별적인 레포지토리를 만드는 방식과는 달리 Lint, CI/CD 등 개발 환경 설정도 통합즉으로 관리하기 때문에 불필요한 코드 중복을 줄여준다.

폴리레포와는 다르게 공통 모듈도 동일한 프로젝트 내에서 관리되므로 별도의 패키지 관리자를 통해 모듈을 게시하지 않아도 된다. 기능 변화를 쉽게 추적하고 의존성을 관리할 수 있게 된다.

#### 모노레포로 관리했을 때의 단점

시간이 지나면서 레포지토리가 거대해질 수 있다. 그리고 하나의 레포지토리에 여러 팀의 이해관계가 얽혀있다면 소유권과 권한 관리가 복잡해질 수 있다. 따라서 각 프로젝트나 모듈의 소유권을 명확히 정의하고 규칙을 설정해야 하는 과정이 별도로 필요하다.

### 후기

#### 모노레포 사용하면서 느낀점

- 모노레포 안에 있는 패키지의 개별적인 버저닝이 필요했다. 디자인 시스템을 개발하고 있기 때문에 패키지 수가 엄청 많았다.
- 유용하지만, 하나의 프로젝트처럼 관리되지 않는 모노레포를 사용할 때는 아쉬운 점이 있다.여러 부서에서 관리하다 보니 깃 로그를 읽고 변경 내역을 빠르게 파악하기 어려웠다. 배포 주기가 각각 달라서 릴리즈 버전을 관리하는 것이 어려웠다.
- pnpm, Learna + npm workspace를 사용해 모노레포를 관리 중이다.버저닝이 확실하게 보장된다는 장점이 있었다. 하지만 모든 패키지를 보게 되어 퍼포먼스가 떨어지는 것 같기도 하다. 공통 의존성이 꼬이는 문제가 발생하면 문제를 해결하는데 많은 리소스가 투입돼서 힘들었다.
- Lerna를 사용한 관련 예시를 보면서 관리하는 법 학습함.
- yarn berry를 모노레포 관리로 사용 중이다. yarn berry가 node_modules를 사용하지 않는 구조를 채택하면서 발생한 문제를 단일 프로젝트에서도 해결하기 어려운데 모노레포를 사용할 때는 더 헤매게 되는 것 같다. nx를 사용하면 이런 단점을 보완할 수 있다. 특정 패키지만 배포해야 할 때 필요한 모듈만 정리해서 제공해준다는 점이 좋았다.
